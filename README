============
fricas-snark        ** under construction **
============
 
Automated Theorem Prover for FriCAS (based on SNARK).


-----------
Quick start
-----------

1. Install QuickLisp (if not done yet ;)
   - add the following three lines to .axiom.input:
   
       )lisp (if (load "~/quicklisp/setup.lisp") '|QuickLisp|)
       )lisp (defun |quickLoad| (p) (ql::quickload p))
       )lisp (defun |quickFind| (p) (ql::system-apropos p))
   
   - if quicklisp is not in "~" then adjust accordingly.
   
2. cd ~/quicklisp/local-projects

3. git clone https://github.com/nilqed/fricas-atp.git

4. start FriCAS

5. -> quickLoad("fricas-snark")$Lisp
   -> snarkInit()$Lisp

   
-------   
Remarks   
-------

a) Available commands: )show PROP
b) Next time only 4 & 5 are necessary to load the prover.
c) snark_init()$Lisp always resets the prover to the default state
   (usually not necessary).
d) Using macros in .axiom.input, e.g. 
      use    ==> quickLoad$Lisp
      lookup ==> quickFind$Lisp
      snark  ==> snarkInit$Lisp
   one can simply write: 
      use "snark" ; atp()
   to start and initialize the prover.

   
------------
Introduction
------------

Principal inference rules are resolution and paramodulation. Some distinctive 
features of SNARK are its support for special unification  algorithms, sorts, 
answer construction for program synthesis, procedural attachment, and 
extensibility by Lisp/SPAD code. SNARK has been used as the reasoning component
of SRI's High Performance Knowledge Base (HPKB) system, which deduces answers 
to questions based on large repositories of information, and as the deductive 
core of NASA's Amphion system, which composes software from components to meet 
users' specifications, e.g., to perform computations in planetary astronomy. 
SNARK has also been connected to Kestrel's SPECWARE environment for software 
development.


-------------
Documentation
-------------

SNARK tutorial ... http://www.ai.sri.com/snark/tutorial/tutorial.html
SNARK paper ...... http://www.sri.com/work/publications/guide-snark
SNARK home ....... http://www.ai.sri.com/~stickel/snark.html
SNARK author ..... https://en.wikipedia.org/wiki/Mark_E._Stickel


---------
prop.spad
---------

The language:

    variables, terms ......  Expression(T), where T has Comparable
    
    /\      ...............  logical conjunction (and)
    \/      ...............  logical disjunction (or)
    >>      ...............  implication (implies, =>)
    <<      ...............  implied by (implied-by, <=)
    ~       ...............  logical negation (not)
    all     ...............  forall quantifier
    ex      ...............  exists quantifier
    
    =       ...............  equality predicate (eq)
    <       ...............  less than predicate (lt)
    >       ...............  greater than predicate (gt)
    <=      ...............  less than or equal predicate (leq)
    >=      ...............  greater than or equal predicate (geq) 


    true(), false(): constant propositions
    
    pred    ...............  builds predicates of any order
                             pred('P,[x,y,z]) -> P(x,y,z)



-------------------------                             
Example (input/ex2.input)
-------------------------

)clear all

   All user variables and function definitions have been cleared.


X ==> EXPR INT  -- Terms

                                                                   Type: Void
P ==> PROP INT  -- Propositions

                                                                   Type: Void
--------
-- Group
--------

* : BOP:=operator 'op  -- group multiplication  


   (3)  op
                                                          Type: BasicOperator
/ : BOP:=operator 'inv -- inverse element


   (4)  inv
                                                          Type: BasicOperator
e:X -- unit element

                                                                   Type: Void
---------
-- Axioms
---------

leftId := all(x,(e*x=x)$P)   -- left unit element


   (6)  (FORALL (x) (= (op e x) x))
                                                   Type: Proposition(Integer)
                                                   
leftInv := all(x,(/x*x=e)$P) -- left inverse


   (7)  (FORALL (x) (= (op (inv x) x) e))
                                                   Type: Proposition(Integer)
                                                   
assoc := all([x,y,z],(x*(y*z)=(x*y)*z)$P)  -- associativity of (*)


   (8)  (FORALL (x y z) (= (op x (op y z)) (op (op x y) z)))
                                                   Type: Proposition(Integer)

                                                   
-------------
-- Hypotheses
-------------

leftCancel := all([x,y,z], (x*y=x*z)$P >> (y=z)$P)  


   (9)  (FORALL (x y z) (IMPLIES (= (op x y) (op x z)) (= y z)))
                                                   Type: Proposition(Integer)
rightId := all(x,(x*e=x)$P)


   (10)  (FORALL (x) (= (op x e) x))
                                                   Type: Proposition(Integer)
rightInv := all(x,(x*/x=e)$P)


   (11)  (FORALL (x) (= (op x (inv x)) e))
                                                   Type: Proposition(Integer)
rightInvUnique := all([x,y],(x*y=e)$P >> (y=/x)$P)


   (12)  (FORALL (x y) (IMPLIES (= (op x y) e) (= y (inv x))))
                                                   Type: Proposition(Integer)
invInvolution := all(x, (/(/x)=x)$P)


   (13)  (FORALL (x) (= (inv (inv x)) x))
                                                   Type: Proposition(Integer)
invProd := all([x,y],( /(x*y)=(/y)*(/x))$P)


   (14)  (FORALL (x y) (= (inv (op x y)) (op (inv y) (inv x))))
                                                   Type: Proposition(Integer)


-- Init/prove

prove(leftCancel,[leftId,leftInv,assoc])


   (15)  PROOF-FOUND
                                                            Type: SExpression
prove(rightId,[leftId,leftInv,assoc])


   (16)  PROOF-FOUND
                                                            Type: SExpression
prove(rightInv,[leftId,leftInv,assoc])


   (17)  PROOF-FOUND
                                                            Type: SExpression
prove(invInvolution,[leftId,leftInv,assoc])


   (18)  PROOF-FOUND
                                                            Type: SExpression
prove(rightInvUnique,[leftId,leftInv,assoc])


   (19)  PROOF-FOUND
                                                            Type: SExpression
prove(invProd,[leftId,leftInv,assoc])


   (20)  PROOF-FOUND
                                                            Type: SExpression
(21) -> printRows()

(Row 1
   (= (op e ?X) ?X)
   SNARK:ASSUMPTION)
(Row 2
   (= (op (inv ?X) ?X) e)
   SNARK:ASSUMPTION)
(Row 3
   (= (op ?X (op ?Y ?Z)) (op (op ?X ?Y) ?Z))
   SNARK:ASSUMPTION)
(Row 6
   (= (op (inv ?X) (op ?X ?Y)) ?Y)
   (SNARK:REWRITE (SNARK:PARAMODULATE 3 2) 1))
...


----------
)show PROP
----------
(24) -> )show P
 Proposition(Integer) is a domain constructor.
 Abbreviation for Proposition is PROP
 This constructor is exposed in this frame.
------------------------------- Operations --------------------------------

 ?/\? : (%,%) -> %                     ?<<? : (%,%) -> %
 ?>>? : (%,%) -> %                     ?\/? : (%,%) -> %
 ?^? : (%,%) -> %                      assert : % -> SExpression
 assume : % -> SExpression             coerce : % -> OutputForm
 convert : % -> InputForm              false : () -> %
 getOption : String -> SExpression     initialize : () -> SExpression
 printAgenda : () -> SExpression       printOptions : () -> SExpression
 printRows : () -> SExpression         printSummary : () -> SExpression
 printTPTP : () -> SExpression         prove : % -> SExpression
 reset : () -> SExpression             runTimeLimit? : () -> SExpression
 true : () -> %                        useParaModulation? : () -> Boolean
 useResolution : Boolean -> Boolean    useResolution? : () -> Boolean
 ~? : % -> %
 ?<? : (Expression(Integer),Expression(Integer)) -> %
 ?<=? : (Expression(Integer),Expression(Integer)) -> %
 ?=? : (Expression(Integer),Expression(Integer)) -> %
 ?>? : (Expression(Integer),Expression(Integer)) -> %
 ?>=? : (Expression(Integer),Expression(Integer)) -> %
 all : (Expression(Integer),%) -> %
 all : (List(Expression(Integer)),%) -> %
 ex : (Expression(Integer),%) -> %
 ex : (List(Expression(Integer)),%) -> %
 getCurrentOptions : () -> Table(String,String)
 getDefaultOptions : () -> Table(String,String)
 ppOptions : Table(String,String) -> Void
 pred : (Symbol,List(Expression(Integer))) -> %
 printRow : PositiveInteger -> SExpression
 prove : (%,List(%)) -> SExpression
 prove? : (%,List(%),%) -> SExpression
 reset : Table(String,String) -> SExpression
 runTimeLimit : PositiveInteger -> PositiveInteger
 setOption : (String,String) -> SExpression
 useHyperResolution : Boolean -> Boolean
 useHyperResolution? : () -> Boolean
 useParaModulation : Boolean -> Boolean


--------------
Tested OS/Lisp
--------------

)lisp (lisp-implementation-version)
Value = "2.48 (2009-07-28) (built on win32 [192.168.150.128])"
)lisp (lisp-implementation-type)
Value = "CLISP"
)sys uname -a
CYGWIN_NT-6.1-WOW64 ajax 1.7.32(0.274/5/3) 2014-08-13 23:03 i686 Cygwin

)lisp (lisp-implementation-version)
Value = "1.2.16"
)lisp (lisp-implementation-type)
Value = "SBCL"
)sys uname -a
Linux helix 3.13.0-49-generic #83-Ubuntu SMP Fri Apr 10 20:11:33 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
